
//
// 07/21/2018
//
// The Gigatron EEPROM is a 16 bit word, 64K word
// location EEPROM.
//
// It is async, so it does not add an extra clock delay  the Gigatron
// instruction fetch + execute loop.
//
// This version is generated using a file and the Verilog
// $readmemh statement.
//
// The Verilog data input file is generated by running the following
// Linux hexdump utility against a pure binary ROM image.
//
// hexdump -v  -e '1/2  "%04X\n"' ROMv1.rom >ROMv1_verilog_data.txt
// hexdump -v  -e '1/2  "%04X\n"' ROMv2.rom >ROMv2_verilog_data.txt
//
// Verify the number of entries generated with:
//
// wc -l ROMv1_verilog_data.txt
// wc -l ROMv2_verilog_data.txt
//
// Note for Windows users: Install Windows Linux subsystem with
// Ubuntu user mode and type "bash" to get a Linux tools
// environment. Cygwin or Altera tools will likely work as well.
//

module Gigatron_EEPROM
(
       input [15:0] address,
       output reg [15:0] data,
       input cs
);

  //  width             depth
  reg [15:0] reg_eeprom [0:65535];

  initial begin

    // ROMv1
//    $readmemh("C:/Dropbox/embedded/altera/workspace/menlo_gigatron_de10_nano/ROMv1_verilog_data.txt", reg_eeprom);

    // ROMv2
    $readmemh("C:/Dropbox/embedded/altera/workspace/menlo_gigatron_de10_nano/ROMv2_verilog_data.txt", reg_eeprom);
  end

  always @ (cs or address) begin

    if (cs == 1'b1) begin
      data = reg_eeprom[address];
    end
    else begin
      data = 8'bz;
    end

  end // end always address

endmodule

`define tb_gigatron_eeprom_assert(signal, value) \
    if (signal !== value) begin \
	     $display("ASSERTION FAILED in %m: signal != value"); \
		  $stop; \
    end

//
// Test bench
//
module tb_gigatron_eeprom();

  reg clock_50;

  reg [15:0] address;
  reg [15:0] data;
  reg cs;
  integer i;

  // Device Under Test instance
  Gigatron_EEPROM DUT(
    .address(address),
    .data(data),
    .cs(cs)
  );

  // Set initial values
  initial begin
     clock_50 = 0;
     address = 0;
     data = 0;
     cs = 0;
  end

  //
  // Setup 50Mhz clock at 1ns resolution.
  //
  // 50mhz == 20ns period.
  // #10 delay is 1/2 of the cycle.
  //
  always #10 clock_50 = ~clock_50;

  // Stimulus to step through values
  initial begin

     cs = 1;
     @(posedge clock_50);


     $display("rdata:");

     for (i = 0; i < 16; i = i + 1) begin

       address = i;
       @(posedge clock_50);

       $display("%d:%h", i, data);

     end

     for (i = 65535 - 16; i < 65536; i = i + 1) begin

       address = i;
       @(posedge clock_50);

       $display("%d:%h", i, data);

     end

     @(posedge clock_50);
     @(posedge clock_50);

     $stop;

  end

endmodule
